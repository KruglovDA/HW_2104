# GUIDE GIT(на несколько домашних заданий)

![Git  суть](Git.png)
 ***

 ***

> Системы контроля версий, одной из которых является *git*, используются при работе с самыми разными проектами, начиная от программных проектов и заканчивая написанием книги или статьи. При работе  с документами мы часто пользуем   ся командами *CTRL+S* (сохранить) и *CTRL+Z(отменить)*, а если мы хотим сделать несколько вариантов, нам приходится сохранять каждый из них в отдельный файл, что не всегда удобно. ***Git*** же позволяет делать все то же самое, но не на уровне отдельного файла, а на уровне целого проекта. Каталог с проектом в этом случае называется репозиторием(*repository*). 
> 
>Каждое такое глобальное CTRL+S называется коммитом (commit) и сохраняет текущую верси. проекта, к которой всегда можно будет вернуться в любой момент (глобальный CTRL+Z). 
>
>Также возможна работа с несколькими версиями, при этом не возникает множества файлов разных версий (на самом деле все изменения сохраняются в системной папке .git находящейся в корне репозитория, и ее лучше не трогать). 
>Кроме того git позволяет
работать с несколькими копиями репозитория, беря на себя все проблемы, связанные с синхронизацией данных. Это не только предохраняет от потерь и данных, но и делает возможным эффективную командную работу над проектом.
***
***

> ***Папка .git***
>
>Когда вы создаете новый репозиторий командой **git init**, Git создает волшебную папку, *.git.* В ней содержится все необходимое для работы Git. Если вы хотите убрать ***Git*** из  вашего проекта, но оставить проектные файлы на диске, просто удалите папку *.git*. Хотя кому такое может потребоваться?

![Содержание волшебной папки](papca.png)

***
***


## Конфигурация
git config --global user.name "[name]" — установить имя, которое будет прикрепляться к коммиту.

git config --global user.email "[email address]" — установить email, который будет прикрепляться к коммиту.

git config --global color.ui auto — включить полезную подсветку командной строки.

git config --global push.default current — обновлять удаленную ветку с таким же именем, что и локальная, при пуше изменений (если не указано иного).

git config --global core.editor [editor] — установить редактор для редактирования сообщений коммита.

git config --global diff.tool [tool] — установить программу для разрешения конфликтов при слиянии.

## Создание репозиториев

git init [project-name] — создать новый локальный репозиторий с заданным именем.

git clone [url] — загрузить проект и его полную историю изменений.

## Работа с изменениями
git status — полный список изменений файлов, ожидающих коммита.

git status -s — краткий вид изменений.

git diff — показать изменения в файлах, которые еще не были добавлены в индекс коммита (staged).

git add [file] — сделать указанный файл готовым для коммита.

git add . — сделать все измененные файлы готовыми для коммита.

git add '*.txt' — добавить только файлы, соответствующие указанному выражению.

git add --patch filename — позволяет выбрать какие изменения из файла добавятся в коммит.

git diff --staged — показать что было добавленно в индекс с помощью git add, но еще не было закоммиченно.

git diff HEAD — показать что изменилось с последнего коммита.

git diff HEAD^ — показать что изменилось с предпоследнего коммита.

git diff [branch] — сравнить текущую ветку с заданной.

git difftool -d — то же самое, что и diff, но показывает изменения в заданной difftool.

git difftool -d master.. — показать изменения, сделанные в текущей ветке.

git diff --stat — показать статистику какие файлы были изменены и как.

git reset [file] — убрать файлы из индекса коммита (изменения не теряются).

git commit — записать изменения в репозиторий. для написания сообщения откроется назначенный редактор.

git commit -m "[descriptive message]" — записать изменения с заданным сообщением.

git commit --amend — добавить изменения к последнему коммиту.

## Работа с ветками

![Основная или главная ветка](main.png)


 ![Пример разветвления](vetki.png)
git branch — список всех локальных веток в текущей директории.

git branch [branch-name] — создать новую ветку.

git checkout [branch-name] — переключиться на указанную ветку и обновить рабочую директорию.

git checkout -b <name> <remote>/<branch> — переключиться на удаленную ветку.

git checkout [filename] — вернуть файл в первоначальное состояние если он еще не был добавлен в индекс коммита.

git merge [branch] — соединить изменения в текущей ветке с изменениями из заданной.

git merge --no-ff [branch] — соединить ветки без режима “fast forwarding”.

git branch -a — посмотреть полный список локальных и удаленных веток.

git branch -d [branch] — удалить заданную ветку.

git branch -D [branch] — принудительно удалить заданную ветку, игнорируя ошибки.

git branch -m <oldname> <newname> — переименовать ветку.

## Работа с файлами

git rm [file] — удалить файл из рабочей директории и добавить в индекс информацию об удалении.

git rm --cached [file] — удалить файл из репозитория, но сохранить его локально.

git mv [file-original] [file-renamed] — изменить имя файла и добавить в индекс коммита.

## Отслеживание файлов

.gitignore — текстовый файл, в котором задаются правила для исключения файлов из репозитория. Например:

*.log
build/
temp-*
git ls-files --other --ignored --exclude-standard — список всех игнорируемых файлов.

## Сохранение фрагментов
git stash — положить во временное хранилище все отслеживаемые файлы.

git stash pop — восстановить последние файлы, положенные во временное хранилище.

git stash list — список всех сохраненных изменений во временном хранилище.

git stash drop — удалить последние файлы, положенные во временное хранилище.

## Просмотр истории
git log — список изменения текущей ветки.

git log --follow [file] — список изменения текущего файла, включая переименования.

git log --pretty=format:"%h %s" --graph — изменение вида отображения истории изменений.

git log --author='Name' --after={1.week.ago} --pretty=oneline --abbrev-commit — посмотреть над чем работал заданный пользователь последнюю неделю.

git log --no-merges master.. — посмотреть историю изменений только для текущей ветки.

git diff [file-branch]..[second-branch] — посмотреть различия между двумя заданными ветками.

git show [commit] — показать метадату и изменения в заданном коммите.

git show [branch]:[file] — посмотреть на файл в другой ветке, не переключаясь на неё.

## Отмена коммитов
git reset — убрать изменения из индекса коммита, сами изменения останутся.

git reset [commit/tag] — отменить все коммиты после указанного коммита, изменения будут сохранены локально.

git reset --hard [commit] — принудительно вернутся к указанному коммиту, не сохраняя историю и изменения.

 ## Синхронизация изменений
git fetch [bookmark] — загрузить всю историю с заданного удаленного репозитория.

git merge [bookmark]/[branch] — слить изменения локальной ветки и заданной удаленной.

git push — запушить текущую ветку в удаленную ветку.

git push [remote] [branch] — запушить ветку в указанный репозиторий и удаленную ветку.

git push [bookmark] :[branch] — в удаленном репозитории удалить заданную ветку.

git push -u origin master — если удаленная ветка не установлена как отслеживаемая, то сделать ее такой.

git pull — загрузить историю и изменения удаленной ветки и произвести слияние с текущей веткой.

git pull [remote][branch] — указать конкретную удаленную ветку для слияния.

git remote — посмотреть список доступных удаленных репозиториев.

git remote -v — посмотреть детальный список доступных удаленных репозиториев.

git remote add [remote][url] — добавить новый удаленный репозиторий.

Пока все

# ***Установка Git***
Создать свой проект и начать пользоваться Git в нем достаточно просто. Мы будем рассматривать работу в командной строке терминала, потому что там реализован полный набор команд. Вероятно, в будущем вам будет проще воспользоваться встроенными инструментами в крупном приложении (например, в Visual Studio, если вы программист).

*Однако командная строка все равно удобна для тонкой настройки и «нестандартных» действий, поэтому полезно представлять себе, как управлять проектом через нее.*

**Сначала потребуется установить Git на свой компьютер.** 

### Установка в Linux
Для дистрибутивов, похожих на Fedora, RHEL или CentOS, выполните команду dnf:

    
> sudo dnf install git-all


На Ubuntu и других Debian-подобных систем введите apt:


> sudo apt install git


Более подробные сведения можно получить по [ссылке](https://git-scm.com/download/linux.)

### Установка на Mac
Один из способов установки — воспользоваться Xcode Command Line Tools. В терминале нужно ввести:

   
> git --version


И следовать дальнейшим инструкциям.

Если вы пользуетесь *Homebrew*, запустите команду:


$ brew install git


Подробности доступны по [ссылке](https://git-scm.com/download/mac).

### Установка в Windows
Новейшая сборка доступна на официальном сайте **Git** по [ссылке](https://git-scm.com/download/win) (загрузка запустится автоматически).
# Ссылки
[  Инструкция  MD](https://paulradzkov.com/2014/markdown_cheatsheet "Я ссылка")

[Инструкция GIT](https://habr.com/ru/companies/vk/articles/493816/ "я инструкция")

# ***Принципы работы с Git*** #

+ У проектных файлов в Git есть 3 базовых состояния

  - Измененные (modified) — файлы в процессе рабочего редактирования.
  - Индексированные (staged) — та часть измененных файлов, которая уже подготовлена к фиксации после редактирования.
  - Зафиксированные (committed) — файлы, уже сохраненные в локальном репозитории.

+ У Git есть рабочий каталог, где хранятся метаданные и локальная база рабочего проекта. Именно эта часть копируется, когда вы клонируете проект (репозиторий) с сервера.

+ Чаще всего работа с Git устроена примерно так:

  - Вы вносите правки в файлы рабочей копии проекта.
  - Индексируете их, подготавливая к коммиту (здесь Git создает снимки новых правок).
  - Делаете коммит, и индексированные правки наконец сохраняются в вашем каталоге Git.

# Настройка Git

**Настроить рабочую среду нужно только один раз — после обновлений параметры не сбросятся. Если понадобится, в любое время можно изменить ваши настройки.**

*Самый удобный способ изменения конфигурации — встроенная утилита git config. Настройки Git имеют три уровня:*

- Параметры из файла [path]/etc/gitconfig (системные) могут работать для всех пользователей системы и репозиториев. Они редактируются командой git config —system.

- Параметры из файла ~/.gitconfig или ~/.config/git/config (глобальные) применяются к одному пользователю, если запустить команду git config —global.

- Локальные параметры из файла config в рабочем каталоге .git/config сохраняют только для выбранного репозитория. Ему соответствует команда git config —local.

***Если запускать git config без параметров, будет использоваться локальный уровень, никакие из более глобальных настроек не изменятся.***

- Всю используемую конфигурацию можно просмотреть так:

    
> git config --list --show-origin


- Представимся Git, чтобы в рабочих коммитах сохранялось ваше авторство:


    
> git config --global user.name "Danil Z"
> git config --global user.email danilz@danilz.com

- Также можно выбрать и текстовый редактор, введя команду git config —global core.editor. Например, чтобы выбрать Emacs, выполните:


    
> git config --global core.editor emacs

- В Windows нужно указывать полный путь к файлу. К примеру, для установки Notepad++ нужно запустить подобную команду:


    
> git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"

*Стоит отметить, что на практике текстовый редактор в Git может и не пригодиться, особенно если вы активно используете стороннее ПО — например, в Visual Studio все текстовые заметки для Git можно писать в отдельном окне. Текстовые редакторы в командной строке отличаются своеобразным управлением, которое потребует от вас отдельного изучения.*

**Общий список текущих настроек просматривается с помощью команды git config —list. Проверить, что записано в любой из доступных настроек, можно командой с ключом  git config <key>:**


    
> git config user.email

# Работа в репозитории
Как правило, есть два варианта начать работу с репозиторием *Git*:

- Можно выбрать локальный каталог и создать новый репозиторий в нем.
- Можно клонировать существующий репозиторий с локального компьютера или сервера. Обычно проекты клонируются именно с сервера.

***Если у вас на компьютере уже есть рабочий проект***, но еще не назначен контроль версий, то нужно 
+ ***сначала перейти в каталог проекта.***

- ## Linux:
    
> cd /home/user/SomeConsoleApp

- ## macOS:
  
> cd /Users/user/SomeConsoleApp

  -  ## Windows:
  
> cd C:/Users/user/SomeConsoleApp

+ ***Инициализируем репозиторий:***
 
> git init

*Команда создаст каталог с именем .git, в котором будут храниться структурные файлы репозитория.* 

**И, наконец, нужно добавить под контроль версий все существующие файлы командой git add . (точка в конце важна!). Можно добавлять и по одному файлу, с помощью git add <имя файла>.** 

Заодно создадим начальный коммит командой git commit:
    
> git add readme.md
> git commit -m 'Initial project version'

Команду git add можно гибко настраивать с помощью дополнительных параметров (флагов), которые подробно описаны в официальной [документации:](https://git-scm.com/docs/git-add.) К примеру, команда git add —force добавит даже игнорируемые файлы, а git add —update позволит обновить отслеживаемые файлы.

В этом репозитории вы можете продолжать работать и дальше, со временем обновляя его и отправляя рабочие версии на сервер.


## Клонирование существующего репозитория
Когда вы работаете в команде, разрабатываемые проекты часто размещают на сервере. Это один из самых распространенных сценариев. Вам нужно получить копию проекта последней версии на свой компьютер, чтобы далее вносить в него свой вклад.

В качестве примера мы будем рассматривать проект, который создадим на [ресурсе](https://github.com/) . После регистрации на сайте и подтверждения по e-mail нужно создать новый репозиторий, как показано на скриншотах.

Видно, что можно выбрать тип репозитория:

публичный (public) – доступ открыт для любого пользователя, однако права на редактирование выдает владелец проекта;
приватный/скрытый (private) — проект виден только владельцу, другие участники добавляются вручную.
Для нашего примера создадим приватный репозиторий под названием SomeConsoleApp и будем работать с ним далее.

Самые удобные способы клонирования проекта — через протоколы HTTP и SSH, прочесть обо всех более развёрнуто можно по [ссылке](https://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols.)

Для наших целей воспользуемся протоколом https и следующей командой:


    
> git clone https://github.com/DanZDev2/SomeConsoleApp  SomeConsoleApp

На вашем компьютере в каталоге, куда вы перешли в командной строке, должен появиться каталог SomeConsoleApp, внутри него — каталог .git и все скачанные файлы репозитория последней версии.

После получения проекта обычно начинается более рутинный рабочий процесс — правки, добавление функционала и т. д. Далее в какой-то момент вы захотите сохранить прогресс в новой версии проекта.

Правила и периодичность обновления могут быть почти любыми, но хорошим тоном обычно считается сохранять рабочую (или промежуточно завершенную) версию. Важное требование для команд разработчиков — возможность сборки проекта, иначе другие участники команды будут вынуждены тратить время на борьбу с ошибками компиляции.

# Теоретический блок работы с удаленными репозиториями

              Оглавление
1. Что такое удаленный репозиторий.
2. Настройка подключения удаленного репозитория. Группа команд git remote.

2.1. Добавление удаленного репозитория к существующему локальному. Команда git remote add.

2.2. Настройка подключения по HTTPS.

2.3. Настройка подключения по SSH.

2.4. Отключение удаленного репозитория от локального. Команда git remote remove.

2.5. Изменение имени удаленного репозитория. Просмотр всех удаленных репозиториев. Команды git remote rename, git remote show.

3. Клонирование удаленного репозитория. Команда git clone.
4. Получение изменений из удаленного репозитория. Команда git fetch.
5. Получение изменений из удаленного репозитория. Команда git pull.
6. Отправка изменений в удаленный репозиторий. Команда git push.
7. GitHub. Работа с репозиторием, создание форков и пулл-реквестов

7.1 Создание репозитория на GitHub

7.2 Страница репозитория на GitHub.

7.3. Создание форка репозитория на GitHub. Пулл-реквесты. 

8. Модель ветвления Git

8.1. Центральный репозиторий

8.2. Основные ветки

8.3. Вспомогательные ветки

8.4. Feature-ветки.

8.5. Release-ветки.

8.6. Hotfix-ветки.



## 1 - Что такое удаленный репозиторий
Сегодня мы познакомимся с  понятием: удаленный репозиторий.

### **Важно**
*Отметим, что здесь и далее, в качестве примера, мы будем использовать сервис хостинга удаленных репозиториев GitHub.* Мы предпочитаем этот сервис за его популярность и множество дополнительных функций, о которых будет рассказано ниже. Тем не менее, если вам больше нравится другой сервис, процесс работы не будет сильно отличаться.

Распределенная система контроля версий – такая система, в которой участники хранят у себя на компьютере полную копию всех версий проекта. Такой принцип делает их независимыми от рабочего сервера.
Git относится к распределенным системам контроля версий.

Удаленный (иногда говорят "внешний") репозиторий – это версии вашего проекта, сохраненные на удаленном сервере. Доступ к репозиторию на таком сервере может осуществляться по интернету или по локальной сети.
Удаленный репозиторий – полноценный репозиторий, ничем не отличающийся от локального. У удаленного репозитория есть собственные ветки, собственный указатель HEAD, своя история коммитов и так далее.

Если мы подключим удаленный репозиторий к своему локальному, то у нас появятся копии всех ссылочных объектов удаленного репозитория. То есть, например, у удаленного репозитория есть ветка main, а у нас будет копия этой ветки – origin/main. Все такие ссылочные объекты (указатели, ветки и теги) удаленного репозитория хранятся почти там же, где и у локального – в директории .git/refs/remotes/<имя_удаленного_репозитория>.

***Кстати***
Принято называть удаленные ветки (то есть ветки удаленных репозиториев), приписывая к их названию имя удаленного репозитория. Например, если у нас есть удаленный репозиторий с именем origin и веткой main, то мы будем называть такую ветку origin/main. То же мы будем делать и со всеми остальными ссылочными объектами. Это может показаться излишним, но на самом деле это добавляет определенности и позволяет не запутаться в многочисленных названиях веток.

Как мы уже говорили в первом уроке, один из плюсов распределенной системы контроля версий заключается в том, что у вас может быть сколь угодно много удаленных репозиториев. Какие-то из них могут быть доступны только на чтение, а какие-то – на чтение и запись.

Таким образом, чтобы стать полноценным пользователем Git, важно овладеть навыками работы с удаленным репозиторием. Среди них – создание новых и копирование к себе уже существующих удаленных репозиториев, загрузка на сервер локальных коммитов и скачивание изменения с сервера. Давайте изучим все это по порядку.

## 2 Настройка подключения удаленного репозитория. 
Группа команд *git remote*.
Необходимость подключить удаленный репозиторий к уже существующему локальному возникает в ситуациях, когда вы решаете выгрузить уже написанный код на удаленный сервер. Это нужно, чтобы другие разработчики смогли получить к нему доступ или чтобы вы сами могли заниматься разработкой с нескольких компьютеров (например, домашнего и рабочего).

Для управления подключением удаленных репозиториев в Git предусмотрена целая группа команд – git remote. Мы рассмотрим самые частоиспользуемые команды из этой группы.

### 2.1. Добавление удаленного репозитория к существующему локальному. 

Команда *git remote add*.
Давайте разберемся, как добавить удаленный репозиторий к вашему локальному репу. Для этого в Git есть команда *git remote add*.
Команда git remote add
Формат
git remote add <название удаленного репозитория> <ссылка на удаленный репозиторий>
Что делает
Подключает удаленный репозиторий к вашему под переданным именем.

Возможно у вас возникнут вопросы: что такое имя удаленного репозитория, и откуда взять ссылку на него. Ответим на них по порядку.

Имя удаленного репозитория в команде *git remote add* вы можете придумать сами. Впоследствии, при работе с этим удаленным репозиторием, вы будете обращаться к нему по придуманному имени. Принято называть удаленный репозиторий origin, но строго говоря, никаких ограничений здесь нет.

Со ссылкой на удаленный репозиторий тоже все просто. Мы работаем с GitHub, поэтому эту ссылку можно взять, нажав на большую зеленую кнопку **Code** на странице репозитория на GitHub.

Получение ссылки на удаленный репозиторий
Вам предложат выбрать одну из трех ссылок: для протоколов https и ssh и для клиента GitHub на компьютер. Вот примеры этих трех ссылок для репозитория geometric_lib известного вам по практическим занятиям этого курса:

HTTPS-ссылка: https://github.com/smartiqaorg/geometric_lib.git
SSH-ссылка: git@github.com:smartiqaorg/geometric_lib.git
GitHub CLI ссылка: gh repo clone smartiqaorg/geometric_lib
Давайте разберемся, в чем отличие. Начнем с последней - эта ссылка используется в клиенте GitHub, который нужен для упрощения работы с Git. Этот клиент можно поставить отдельно, но его возможности значительно ограничены по сравнению с консольным вариантом Git.

Итак, с последней ссылкой все понятно: ее нужно использовать в специальной программе для компьютера с графическим UI от создателей GitHub. Но в чем разница между первыми двумя?

Дело в том, что существует два основных протокола подключения к git-серверу: HTTPS и SSH. SSH считается более надежным, но он немного сложнее в настройке. Давайте разберемся, как настроить подключение для каждого из них. А окончательный выбор протокола оставим на вкус читателя.

### 2.2. Настройка подключения по HTTPS

Раньше можно было подключаться по HTTPS, используя имя пользователя и пароль от аккаунта GitHub. Но потом эту возможность отключили в целях безопасности. Сейчас вместо пароля нужно использовать персональный токен. Давайте разберемся, как создать такой токен.

Итак, чтобы создать токен персонального доступа, следуйте инструкции:
1. Подтвердите свой email-адрес, который вы использовали при регистрации аккаунта GitHub (если он не подтвержден
2. Кликните на свою аватарку в правом верхнем углу, в открывшемся окне выберите Settings (Настройки):
3. Перед вами откроются настройки. В меню слева выберите Developer settings (Настройки разработчика)
4. Перед вами откроются Настройки разработчика. В меню слева выберите Personal access tokens (токены персонального доступа).
5. Нажмите Generate new token (сгенерировать новый токен)
6. Придумайте имя для своего токена. Имя должно описывать, зачем токен был создан.
7. Дайте токену разрешения. Пользователь токена сможет выполнять с удаленным репозиторием только то, что вы указали в этих разрешениях. Чтобы дать токену доступ к управлению удаленным репозиторием из командной строки, выберите repo.
8. Нажмите Generate token (сгенерировать токен).
Пример токена
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
9. Скопируйте токен. В целях безопасности, как только вы покинете страницу создания токена, вы больше не сможете просмотреть этот токен.
Отлично, ваш токен готов! При первой загрузке/скачивании изменений из удаленного репозитория, вас попросят ввести имя пользователя на GitHub и пароль. Нужно будет ввести свое имя пользователя, а вместо пароля вставить этот токен.

### 2.3. Настройка подключения по SSH

Чтобы настроить подключение по SSH, вам нужно на своем компьютере сгенерировать два SSH-ключа: публичный (public) и секретный (private).
Немного про SSH
Как работает SSH протокол и зачем ему ключи? Если коротко, то публичный ключ передается на удаленный сервер, а секретный все время остается с вами. Удаленный сервер использует публичный ключ, чтобы удостовериться, что у вас действительно есть секретный ключ. Как только сервер убеждается в наличии у вас секретного ключа, он понимает, что вы – это вы, ведь секретный ключ нельзя подделать.
После создания пары ключей, надо добавить секретный ключ в SSH-агента.
Про SSH агента
SSH-агент – это специальная программа, которая сохраняет пароль от файла с секретным ключом и помогает удаленному серверу удостовериться, что вы действительно владеете секретным ключом. Благодаря SSH-агенту, вам не потребуется при каждом подключении к удаленному серверу вводить пароль от файла с приватным ключом.
После останется только загрузить наш публичный ключ на GitHub и готово. Давайте рассмотрим этот процесс подробнее:

1. Откройте Git Bash (или терминал, если вы работаете на Linux/MacOS)
2. Выполните в нем команду ssh-keygen -t rsa 4096 -C "<ваша-почта>@example.com"
2.1. Вам предложат ввести путь к директории, в которой будет сохранен ключ, а также будет выведена директория для сохранения по умолчанию. Нажмите Enter, чтобы выбрать директорию по умолчанию, либо введите любую другую директорию и тоже нажмите Enter.
2.2. Затем вам предложат ввести пароль для файла с секретным ключом. Нажмите Enter, чтобы оставить файл без пароля, либо введите пароль и нажмите Enter.
3. Теперь нужно добавить ключ в SSH-агента. Запустим агента командой eval `ssh-agent -s`
4. Теперь выполните команду ssh-add <путь до приватного ключа>. Если вы оставили путь по умолчанию, ваша команда будет выглядеть так: ssh-add ~/.ssh/id_ed25519
5. Отлично, последний этап: добавляем публичный ключ на GitHub. Для этого откройте файл с публичным ключом (он должен иметь расширение .pub). Если вы оставили путь по умолчанию, то ваш ключ будет располагаться по адресу ~/.ssh/id_ed25519.pub.
6. Скопируйте содержимое файла.
7. Перейдите в настройки GitHub
8. Откройте раздел SSH and GPG keys (ssh и gpg ключи)
Раздел “SSH and GPG keys” и кнопка “New SSH key”
Раздел "SSH and GPG keys" и кнопка "New SSH key"
9. Нажмите New SSH key (новый ssh-ключ)
10. В поле Title (заголовок) введите содержательное название ключа, например ключ для ноутбука или ключ рабочего компьютера
Заполнение полей SSH ключа
Заполнение полей SSH ключа
11. Скопированный ключ вставьте в раздел Key (ключ)
12. Нажмите Add SSH key (добавить ssh-ключ)
13. Возможно потребуется ввести пароль для подтверждения действия.

Теперь SSH-ключ добавлен. Вам больше не нужно вводить имя пользователя и пароль при каждой загрузке или скачивании изменений из удаленного репозитория.

## 2.4. Отключение удаленного репозитория от локального. Команда *git remote remove*.

Иногда возникает необходимость забыть удаленный репозиторий. Для этого существует команда *git remote remove*.
Команда *git remote remove*
Формат *git remote remove <название удаленного репозитория>* - Отключает переданный удаленный репозиторий от вашего.
**Данная команда предельно проста в использовании. В качестве имени репозитория нужно передавать то имя, которое вы указывали в команде git remote add. Заметьте, данная команда не удаляет удаленный репозиторий с сервера, она удаляет только подключение вашего репозитория к удаленному.**

## 2.5. Изменение имени удаленного репозитория. 

Просмотр всех удаленных репозиториев. Команды *git remote rename, git remote show.*
Иногда возникает необходимость переименовать удаленный репозиторий. Для этого существует команда *git remote rename.*
Команда *git remote rename*

Формат
*git remote rename <старое имя удаленного репозитория> <новое имя удаленного репозитория>* - 
меняет имя переданного удаленного репозитория

Еще более частая задача – просмотреть список всех подключенных удаленных репозиториев и получить информацию о каждом из них. Для этого существует команда *git remote show.*
Команда *git remote show*

Формат

*git remote show [имя удаленного репозитория]- выводит список всех подключенных удаленных репозиториев. Если передано имя репозитория, то выводит информацию об этом репозитории.
Таким образом можно просмотреть информацию о каждом из подключенных удаленных репозиториев.

## 3 Клонирование удаленного репозитория.

Команда *git clone.*
Теперь, когда мы разобрались с настройкой подключения удаленного репозитория к уже существующему, давайте узнаем, как можно склонировать удаленный репозиторий к себе на компьютер. Операция клонирования создаёт на вашем компьютере точную копию удаленного репозитория.

Необходимость клонировать существующий удаленный репозиторий возникает в ситуациях, когда вы решаете поработать над уже существующим кодом. Для выполнения этой операции в Git предусмотрена команда *git clone.*
Команда *git clone*

Формат

git clone <ссылка на удаленный репозиторий> - Клонирует переданный репозиторий на ваш компьютер.

Ссылку на удаленный репозиторий можно получить тем же способом, что мы разбирали выше. Нужно нажать на зеленую кнопку Code на главной странице репозитория на GitHub.

***Заметьте, что клонирование по https возможно вообще всегда, а по ssh – нет. Чтобы клонировать репозитории по ssh, нужно, чтобы владелец удаленного репозитория на GitHub добавил к себе публичный ssh-ключ из пары, в то время, как секретный ssh-ключ от той же пары хранится у вас на компьютере, с которого вы выполняете *git clone.* Таким образом, если вы настроили ssh в своем аккаунте, то вы сможете беспрепятственно клонировать свои репозитории и по https, и по ssh. Но если вы пытаетесь клонировать чужой репозиторий по ssh, то скорее всего получите ошибку доступа.***
## Важно
Окончательный выбор протокола для клонирования, конечно, остается за читателем. Работать по https проще и быстрее, зато он считается менее защищенным, чем ssh, который в свою очередь труднее в настройке.

# 4 Получение изменений из удаленного репозитория. Команда *git fetch*
Теперь, когда мы научились подключать удаленный репозиторий к локальному и клонировать его к себе на компьютер, пора узнать, как же получить изменения из удаленного репозитория.

У вас может возникнуть вопрос: зачем получать изменения, если только я загружаю их в свой удаленный репозиторий? Все верно, если вы работаете один, то вряд ли вам пригодится загружать изменения из удаленного репозитория в локальный. Но если вы работаете в команде, вы будете по несколько раз в день обновлять свой репозиторий, загружая в него коммиты, сделанные другими разработчиками из вашей команды.

Итак, чтобы получить изменения из удаленного репозитория, в Git предусмотрена команда *git fetch.*
Команда *git fetch*

Формат

*git fetch* [ключи] [имя удаленного репозитория]
Ключи --all - Получает изменения из всех подключенных удаленных репозиториев - получает изменения из переданного удаленного репозитория. Если не было передано ни одного удаленного репозитория, ни ключа --all, команда пытается получить изменения из репозитория с именем origin.

**Важным замечанием здесь станет то, что команда не обновляет рабочую копию в соответствии с удаленным репозиторием. Она обновляет только ссылочные объекты (указатели, ветки и теги) и скачивает все необходимые файлы в директорию *.git/objects*.**

#5 Получение изменений из удаленного репозитория. Команда *git pull*
Связкой *git fetch && git merge* мы получили изменения из удаленного репозитория и обновили свою рабочую копию. Часто вместо этого хочется получать изменения и сразу обновлять рабочую копию так, чтобы она соответствовала удаленному репозиторию. И для этого в Git существует отдельная команда. Называется она *git pull.*
Команда *git pull* 

Формат

*git pull [ключи] [имя удаленного репозитория]*
Ключи
*--ff*
*--no-ff*
*--ff-only*
Эти ключи определяют стратегию слияния. --ff – включить fast-forward, если это возможно, --no-ff – отключить fast-forward, а --ff-only – остановить pull, если его невозможно сделать в fast-forward. - 
Получает изменения из переданного удаленного репозитория и обновляет рабочую копию в соответствии с удаленным репозиторием. По умолчанию слияние удаленной ветки с локальной происходит именно в fast-forward режиме, так что включать его специально не требуется

***На самом деле, новых команд здесь нет. Команда git pull это просто сокращение последовательного применения git fetch и git merge. Но используется git pull намного чаще.***
### Подведем итог

Команда *git pull* используется для синхронизации локальной рабочей копии и всех ссылочных объектов с удаленным репозиторием.
По сути, *git pull* - это то же самое, что *git fetch + git merge.*
# 6 Отправка изменений в удаленный репозиторий. 

Команда *git push*
Мы знаем почти все про удаленный репозиторий. Осталось изучить, как загружать в него свои локальные изменения. 
Для этого в Git существует команда *git push.*
Команда *git push*

Формат
*git push [ключи] [имя удаленного репозитория] [имя ветки]*
Ключи
*--all*
Пушит все имеющиеся ветки

*-f, --force*
Перезаписывает удаленную ветку, вне зависимости от ее содержимого. Старайтесь не использовать этот флаг без крайней необходимости.

*--force-with-lease*
Удаляет все коммиты, которых нет в локальном репозитории. Если коммит, который команда соберется удалять был создан другим пользователем, то выполнение закончится с ошибкой.

Другие ключи


Что делает
Загружает изменения в удаленный репозиторий. Если слияние изменений в удаленном репозитории нельзя сделать в режиме *fast-forward,* и при этом не был передан ключ *force,* выполнение закончится с ошибкой.
Пример
По факту данная команда аналогична связке *git fetch + git merge,* но выполненной из удаленного репозитория (это просто аналогия, на самом деле так сделать не получится).

Давайте более подробно разберем, как работает эта команда. Допустим, мы выполнили *git push origin develop* в нашем локальном репозитории. Возможны три варианта развития событий.

- Если изменения с нашей ветки можно слить с удаленной веткой в режиме *fast-forward,* то есть на удаленной ветке нет коммитов сделанных после наших, то все пройдет нормально.

- Если на удаленной ветке есть коммиты, которые были сделаны позже наших, то есть слияние в режиме *fast-forward* выполнить невозможно, то команда завершится с ошибкой. Ведь в этом случае есть угроза перезаписи истории удаленного репозитория и удаления всех коммитов, созданных позже наших.

- Но если вы вдруг передали флаг *--force,* то все коммиты, которых нет в вашем локальном репозитории, будут удалены. То есть удаленный репозиторий станет точной копией вашего локального. Есть более щадящая версия этого флага *– --force-with-lease.* Он будет делать в точности то же самое, но если вдруг нужно будет удалить коммит, созданный не вами, выполнение немедленно прекратится и вернется ошибка. Таким образом, вы не попадете в ситуацию, когда вы случайно удалили чужой коммит.

# 7 GitHub. Работа с репозиторием, создание форков и пулл-реквестов

Научившись работать с локальным репозиторием, освоим основы работы с GitHub. Итак, если коротко, то GitHub – это, наверное, самый популярный сервис бесплатного хостинга удаленных репозиториев с множеством дополнительных функций. Среди них есть, например, создание *issue* – запросов, в которых можно сообщить разработчикам об ошибках, создание репозиториев-форков и пулл-реквестов. Кроме того, на GitHub можно подписаться на обновления какого-то конкретного пользователя или включить отслеживание репозитория вашего любимого проекта. Все это превращает GitHub в настоящую социальную сеть для разработчиков по всему миру. Давайте приступим к изучению основ работы с этим сервисом.

## 7.1 Создание репозитория на GitHub

*Прежде всего вам необходимо зарегистрироваться на GitHub, но это довольно тривиальный процесс, так что его мы здесь опустим. После регистрации вы попадете на главную страницу. На ней будут отображаться действия людей, на которых вы подписались и обновления в репозиториях, которые вы добавили в избранное.*

- Чтобы создать свой репозиторий, нажмите на зеленую кнопку New, как показано на рисунке.
Создание репозитория - кнопка “New”
Создание репозитория - кнопка "New"
Перед вами откроется страница создания репозитория. Давайте разберем, что за поля нам предлагают заполнить.

- Итак, первое поле Repository name – имя репозитория. Здесь все просто, вам нужно придумать имя, которое будет отображаться на странице вашего репозитория. Здесь нет никаких ограничений, но старайтесь давать как можно более содержательные имена своим репозиториям.
Второе поле – Description – описание. Его заполнять необязательно. Но другим пользователям, которые попали на страницу вашего репозитория, будет проще понять, что перед ними, если вы заполните графу описания.
- Затем вы можете выбрать, будет ли репозиторий открытым, то есть доступным абсолютно всем пользователям GitHub, или закрытым, то есть доступным только вам и людям, которым вы предоставите доступ.
- Последние три поля предлагают нам добавить, соответственно, README-файл, .gitignore файл и выбрать лицензию для нашего проекта.

Завершим процесс создания репозитория, нажав кнопку Create repository.

## 7.2 Страница репозитория на GitHub.
После создания репозитория, мы попадем на его страницу на GitHub. В нашем случае эта страница будет выглядеть так.
Страница репозитория на GitHub
Страница репозитория на GitHub
Как видно из рисунка, GitHub автоматически создал первый коммит, добавив в него файл .gitignore и файл README.

Кстати, можно заметить, что содержимое файла README выводится под рабочей копией репозитория. Это одна из особенностей GitHub. Вы в любое время можете создать файл с именем README.md и запушить его в свой удаленный репозиторий на GitHub. Тогда содержимое этого файла будет отображаться прямо на странице вашего репозитория.

В верхнем меню мы видим 9 разных вкладок. Давайте разберем их по порядку.

1. Вкладка Code. Сейчас открыта именно она. В ней содержится рабочая копия нашего репозитория (по центру), описание (справа), вывод файла README (под рабочей копией), история коммитов, а также кнопки для клонирования репозитория и просмотра файлов.
2. Вкладка Issues. В этой вкладке будут отображаться все запросы, сделанные другими пользователями. Как правило, пользователи используют запрос, чтобы сообщить о найденном баге, либо чтобы задать какой-то вопрос о вашем приложении.
3. Вкладка Pull-requests. На этой вкладке будут отображаться все пулл-реквесты, сделанные другими пользователями. О том, что такое пулл-реквесты, мы поговорим ниже.
4-5. Вкладки Actions и Project относятся скорее к системе CI/CDI, которую предоставляет GitHub, в этом курсе мы не будем затрагивать их.
6. Вкладка Wiki открывает вам доступ к созданию и размещению документации о собственном проекте.
7. На вкладке Security содержатся различные настройки безопасности вашего проекта. Там же можно включить инспекцию вашего кода, чтобы узнать, если вы случайно загрузите какой-нибудь секретный токен на GitHub.
8. Вкладка Insight содержит различную информацию и статистические данные об активности репозитория. Там вы сможете посмотреть на зависимость количества коммитов в репозитории от времени или на процент коммитов, сделанных вами.
9. Последняя вкладка – Settings. В ней находятся различные настройки вашего репозитория. Там вы можете поменять видимость репозитория, сделав его частным, или вовсе удалить репозиторий.

# 7.3. Создание форка репозитория на GitHub. Пулл-реквесты.

Итак, одной из самых важных частей GitHub является создание форков.

*Форк (от англ. fork – вилка) – точная копия репозитория, но в вашем аккаунте. Форки нужны, чтобы вносить свои изменения в проект, к репозиторию которого у вас нет прямого доступа.*

*Пулл-реквест (от англ. pull-request – запрос pull) – функция GitHub, позволяющая попросить владельца репозитория, от которого мы сделали форк, загрузить наши изменения обратно в свой репозиторий.*

Если коротко, форки и пулл-реквесты нужны, чтобы любой пользователь мог внести свой вклад в любой открытый проект, репозиторий которого есть на GitHub. Кроме того, перед тем как влить ваши изменения в основной репозиторий, ответственные обязательно проверят ваш код на наличие ошибок и уязвимостей. Таким образом, даже если ваши изменения не примут, вы получите первоклассный code-review с указанием всех неточностей.

# 8 Модель ветвления Git
В этом разделе мы познакомимся с наиболее удачной моделью организации ветвления в большом проекте.
## 8.1. Центральный репозиторий

Итак, основой нашей модели будет центральный репозиторий. Строго говоря, в Git не может быть никаких центральный репозиториев, поскольку это распределенная система контроля версий. Поэтому центральный репозиторий является таковым только с точки зрения логики его использования, с технической же точки зрения – это точно такой же репозиторий, как и все остальные. У каждого из разработчиков в команде есть копия основного репозитория. Схематически ситуация выглядит так:

- Основной репозиторий проекта (origin) и репозитории разработчиков

- Центральный репозиторий на картинке назван origin. Как мы уже упоминали выше, это одно из общепринятых наименований в Git.

Процесс разработки построен на том, что каждый разработчик пушит свой код в основной репозиторий и пуллит код других разработчиков из него. Кроме того, допускаются ситуации, когда разработчики обмениваются кодом друг с другом, – минуя центральный репозиторий. Необходимость такого обмена может возникнуть, когда, например, два девелопера работают над одной функцией. В таком случае им необходим код друг друга, но пушить не готовую функцию в основной репозиторий ни один из них не может.

## 8.2. Основные ветки

В нашей модели существуют две главные ветки:
- main – ветка, в которой содержится только код, готовый к релизу.
- develop – ветка, в которой содержатся изменения, готовые ко включению в последующий релиз.

Эти ветви называются главными, поскольку существуют в центральном репозитории и всех его копиях все время. Логика работы с ними не предполагает их удаления после выпуска очередного релиза, в отличие от, например, вспомогательных ветвей группы release.

Как только в ветке develop появляется достаточно изменений для создания нового релиза, она вливается в ветку main (напрямую или посредством создания специальной ветки release-*, о которой мы поговорим позже). После чего соответствующий коммит слияния в ветке main помечается тегом с указанием версии релиза (напомним, что тег – это статический указатель, нужный для удобства переключения между коммитами).

Таким образом, коммит в ветке origin/main означает выпуск нового релиза. Кстати, если строго придерживаться этого правила, можно организовать непрерывную интеграцию при помощи как встроенных средств GitHub, так и сторонних инструментов, специализирующихся на CI/CDI.

## 8.3. Вспомогательные ветки

Чтобы поддерживать независимость разработки отдельных частей проекта, наша модель включает в себя несколько групп вспомогательных ветвей. Главное отличие таких ветвей от главных в том, что срок жизни этих ветвей ограничен. После завершения выполнения определенной работы, вспомогательная ветвь вливается в одну из главных, после чего удаляется.

Наша модель предполагает существование следующих групп вспомогательных ветвей:
Ветви для разработки новых функций. Они же *feature branches.*
Ветви релизов, то есть *release branches.*
Ветви срочных исправлений – *hotfix branches.*

Чуть ниже мы разберем предназначение каждой группы. Кроме того, мы договоримся о правилах создания, именования и слияния ветвей из каждой группы. Конечно, Git не ограничивает ни в именах ветвей, ни в чем либо другом, – эти условности мы придумываем сами. Тем не менее, такие правила необходимы для облегчения взаимодействия нескольких разработчиков внутри одного большого проекта.

## 8.4. Feature-ветки

***Могут порождаться от: develop
Могут вливаться в: develop
Правило именования: любое имя, кроме main, develop, release-*, hotfix-*.***

Ветки функциональности используются для разработки новых функций, для которых неизвестно: будут ли они добавлены в ближайший релиз или же в какой-то более поздний. Основной смысл такой ветки в том, что живет она ровно столько, сколько продолжается разработка функции, для которой была создана эта ветка. В это время в ветке main могут выходить релизы, не затрагивающие разрабатываемую функцию. По завершении создания функции, такая ветка либо вливается в ветку develop, либо удаляется, если эксперимент с новой функцией не удался.

Feature-ветки существуют в основном только в репозиториях разработчиков, но могут на некоторое время появиться и в центральном репозитории.

## 8.5. Release-ветки

***Могут порождаться от: develop
Могут вливаться в: develop, main
Правило именования: release-****

Ветки релизов необходимы для подготовки к выпуску новых релизов вашего продукта. Их главное назначение – внести финальные штрихи перед выпуском новой версии. В этих ветках можно вносить небольшие изменения и подготавливать файлы с метаданными о версии вашего продукта. Release-ветку следует создавать в тот момент, когда ваш проект готов или почти готов к выпуску очередной версии. По крайней мере не раньше, чем вся функциональность, предназначенная к выходу в этом релизе, будет влита в ветку develop.

Решение о номере версии релиза принимается только после создания release-ветки и опирается на принятые в компании правила нумерации версий. До тех пор неясно, будет ли новый релиз иметь версию 4.1.5, 4.2 или 5.0. Создать release-ветку можно следующим образом.

**На этой ветви запрещено вносить какие-то крупные изменения или исправлять серьезные ошибки, ее предназначение не в этом.**

Как только все файлы вашего проекта будут готовы к выпуску релиза, данную ветвь можно слить в основную ветку main, что и будет соответствовать выпуску релиза. После чего нужно пометить релиз соответствующим тегом, чтобы впоследствии к нему было проще обращаться. Важно не забыть слить изменения с release-ветки в ветку develop, чтобы вернуть наши незначительные изменения в процесс разработки следующего релиза.

# 8.6. Hotfix-ветки

***Могут порождаться от: main
Могут вливаться в: develop, main
Правило именования: hotfix-****

Ветки срочных исправлений или hotfix-ветки, нужны для внесения срочных исправлений в уже вышедший релиз. Такую ветку необходимо создать в ситуации, когда в недавно вышедшем релизе был обнаружен серьезный баг. Предназначение этой ветки – исправить ошибку в последнем вышедшем релизе, а затем выпустить новый релиз, слив ветку hotfix в main и develop. Смысл создания отдельной ветки в том, что работа большей части команды может продолжаться над выходом нового стабильного релиза на ветке develop, пока bugfix-команда работает над исправлением ошибки в последнем релизе в ветке hotfix.

